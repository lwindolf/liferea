/* batchfeedproperty.c generated by valac 0.26.1, the Vala compiler
 * generated from batchfeedproperty.vala, do not modify */

#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

#include <libxml/uri.h>
#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gtk/gtk.h>

#include "ui/batch_feed_property.h"
#include "common.h"
#include "db.h"
#include "node.h"
#include "feed.h"
#include "subscription.h"
#include "feedlist.h"
#include "ui/liferea_shell.h"
#include "ui/feed_list_node.h"
#include "ui/feed_list_view.h"

#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

struct _BatchFeedPropertyPrivate {
	GHashTable*	changed;
	GtkDialog*	main_dialog;
	GtkBuilder*	builder;
};


static gpointer batch_feed_property_parent_class = NULL;

#define BATCH_FEED_UI_FILE (PACKAGE_DATA_DIR G_DIR_SEPARATOR_S PACKAGE G_DIR_SEPARATOR_S "batch_feed_property.ui")
#define BATCH_FEED_PROPERTY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_BATCH_FEED_PROPERTY, BatchFeedPropertyPrivate))
enum  {
	BATCH_FEED_PROPERTY_DUMMY_PROPERTY
};

const gchar *BATCH_FEED_PROPERTY_CSS_CHANGED_CLASS = "batch-feed-property-changed";
const gchar *BATCH_FEED_PROPERTY_CSS_FILENAME = "batch_feed_property.css";

/*
 * Data for specific FileChooser dialog
 */
struct BatchSelectFileData {
	gchar *title;
	gchar *entry_name;
	BatchFeedProperty * self;
};

static void _g_free0_ (gpointer var);
static void _batch_install_css_file(const gchar *css_fname);
static void _batch_install_css_once();
static GObject* _batch_get_object (BatchFeedProperty* self, const gchar* widget_name);
static gboolean _batch_changed(BatchFeedProperty *self, gchar *key);
static gboolean _batch_checkbox_actived(BatchFeedProperty *self, const gchar *key);
static gchar* _batch_decode_url_source(BatchFeedProperty *self, subscriptionPtr subscription);
static gchar* _batch_decode_source(BatchFeedProperty *self, subscriptionPtr subscription);
static void batch_feed_property_change_feed(BatchFeedProperty *self, subscriptionPtr subscription);
static void on_batch_feed_property_dialog_response (GtkDialog* dlg, gint response_id, gpointer user_data);
static void batch_feed_property_on_property_changed (GtkWidget* wid, gpointer self);
static void _batch_select_file_response(GtkFileChooserDialog *dlg, gint resp, gpointer user_data);
static void on_batch_feed_property_select_file(GtkWidget *wid, struct BatchSelectFileData *user_data);

static void batch_feed_property_finalize (GObject* obj);

static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}

static void
_batch_install_css_file(const gchar *css_fname)
{
	GtkCssProvider *css;
	GdkScreen *screen;

	css = gtk_css_provider_new();
	gtk_css_provider_load_from_path(css, css_fname, NULL);
	screen = gdk_screen_get_default();
	gtk_style_context_add_provider_for_screen(screen, GTK_STYLE_PROVIDER(css),
			GTK_STYLE_PROVIDER_PRIORITY_USER);
}

static void
_batch_install_css_once()
{
	static gboolean init_flag = FALSE;
	gchar *filename_css;

	if (TRUE == init_flag)
		return;
	init_flag = TRUE;

	filename_css = common_create_config_filename (BATCH_FEED_PROPERTY_CSS_FILENAME);
	if (!g_file_test (filename_css, G_FILE_TEST_EXISTS)) {
		_g_free0_(filename_css);
		filename_css = g_build_filename (PACKAGE_DATA_DIR, PACKAGE, "css", BATCH_FEED_PROPERTY_CSS_FILENAME, NULL);
	}
	_batch_install_css_file(filename_css);
	_g_free0_(filename_css);
}

BatchFeedProperty*
batch_feed_property_construct (GType object_type, GtkWindow* parent)
{
	BatchFeedProperty *self = NULL;
	GtkBuilder* builder;
	GtkDialog* dialog;

	self = (BatchFeedProperty*) g_object_new (object_type, NULL);
	self->priv->changed = g_hash_table_new_full (g_str_hash, g_str_equal, _g_free0_, NULL);
	builder = gtk_builder_new ();
	self->priv->builder = builder;
	gtk_builder_add_from_file (builder, BATCH_FEED_UI_FILE, NULL);
	gtk_builder_connect_signals (builder, self);
	dialog = GTK_DIALOG(gtk_builder_get_object (builder, "dialog_batch_props"));
	self->priv->main_dialog = dialog;
	gtk_window_set_transient_for ((GtkWindow*) dialog, parent);
	g_signal_connect(G_OBJECT(dialog),
			"response",
			G_CALLBACK(on_batch_feed_property_dialog_response),
			self);

	_batch_install_css_once();

	/* load tree */
	GtkTreeView *life_tree = GTK_TREE_VIEW(liferea_shell_lookup ("feedlist"));
	GtkTreeView *tree = GTK_TREE_VIEW(_batch_get_object(self, "treeview_feed_list"));
	gtk_tree_view_set_model(tree, gtk_tree_view_get_model(life_tree));

	return self;
}

BatchFeedProperty*
batch_feed_property_new (GtkWindow* parent)
{
	return batch_feed_property_construct (TYPE_BATCH_FEED_PROPERTY, parent);
}

struct WidgetBox {
	gchar *widget_prefix;
	gchar *container_name;
} BOX_MAP[] = {
	{"updateInterval", "gridv237"},
	{"feed_loc_", "grid7"},
	{"filter", "gridv2620"},
	{"feedCache", "gridv240"},
	{"HTTPauth", "grid1"},
	{},
};

struct SensitiveMap {
	gchar *widget_name;
	gchar *target_name;
} SENSITIVE_MAP[] = {
	{"updateIntervalSpecific", "gridh71"},
	{"feed_loc_file", "selectSourceFileButton"},
	{"filterCheckbox", "innerfiltervbox"},
	{"feedCacheLimited", "cacheItemLimit"},
	{"HTTPauthCheck", "alignment34"},
	{},
};

/**
 * run the batch property change dialog
 */
void
batch_feed_property_run (BatchFeedProperty* self)
{
	GtkDialog* dlg = self->priv->main_dialog;
	gtk_dialog_run (dlg);
}

/**
 * menu action for batch feed property change
 */
void
on_menu_batch_feed_property_change (GtkMenuItem *menuitem, gpointer user_data)
{
	GtkWindow *parent = GTK_WINDOW(liferea_shell_get_window());
	BatchFeedProperty* self = batch_feed_property_new(parent);
	batch_feed_property_run(self);
}

/**
 * Shortcut to get widget/object from the GtkBuilder
 */
static GObject*
_batch_get_object (BatchFeedProperty* self, const gchar* widget_name)
{
	GObject* result = NULL;
	GtkBuilder* builder = self->priv->builder;
	result = gtk_builder_get_object (builder, widget_name);
	return result;
}

/**
 * Shortcut to get widget/object from the GtkBuilder
 */
static gboolean
_batch_changed(BatchFeedProperty *self, gchar *key)
{
	return g_hash_table_contains(self->priv->changed, key);
}

/**
 * Shortcut to get `active` value from a GtkToggleButton in GtkBuilder
 */
static gboolean
_batch_checkbox_actived(BatchFeedProperty *self, const gchar *key)
{
	GtkToggleButton *checkbox;
	checkbox = GTK_TOGGLE_BUTTON(_batch_get_object(self, key));
	return gtk_toggle_button_get_active(checkbox);
}

/**
 * Compose changed URL string from current dialog and subscription
 */
static gchar*
_batch_decode_url_source(BatchFeedProperty *self, subscriptionPtr subscription)
{
	const gchar *username, *password;
	gchar *source = NULL;
	gchar **user_parts = NULL;
	const gchar *source_text;
	xmlChar *sourceUrl;
	GtkEntry *entry;

	xmlURIPtr source_uri = NULL;
	xmlURIPtr source_uri_old = NULL;

	gboolean url_changed = _batch_checkbox_actived(self, "feed_loc_url");
	gboolean auth_changed = _batch_changed(self, "HTTPauth");

	password = username = NULL;

	url_changed = url_changed && _batch_changed(self, "feed_loc_");
	source_uri_old = xmlParseURI(BAD_CAST subscription_get_source(subscription));

	if (auth_changed) {
		gboolean auth_active = _batch_checkbox_actived(self, "HTTPauthCheck");
		if (auth_active) {
			entry = GTK_ENTRY(_batch_get_object(self, "usernameEntry"));
			username = gtk_entry_get_text (entry);
			entry = GTK_ENTRY(_batch_get_object(self, "passwordEntry"));
			password = gtk_entry_get_text (entry);
		}
	} else if (source_uri_old && source_uri_old->user) {
		user_parts = g_strsplit(source_uri_old->user, ":", 2);
		if (user_parts && NULL != user_parts[0]) {
			username = user_parts[0];
			password = user_parts[1];
		}
	}

	if (url_changed) {
		entry = GTK_ENTRY(_batch_get_object(self, "sourceEntry"));
		source_text = gtk_entry_get_text(entry);
		url_changed = *source_text && TRUE;
	}

	if (url_changed ) {
		source_uri = xmlParseURI(source_text);
	} else {
		source_uri = source_uri_old;
	}

	/* set user/password */
	if (source_uri) {
		xmlFree(source_uri->user);
		if (password && *password) {
			source_uri->user = g_strdup_printf("%s:%s", username, password);
		} else {
			source_uri->user = g_strdup(username);
		}
		sourceUrl = xmlSaveUri(source_uri);
		source = g_strdup(sourceUrl);
		g_free(source_uri->user);
		source_uri->user = NULL;
		xmlFree(sourceUrl);
		xmlFreeURI(source_uri);
	}

	if (url_changed && source_uri_old) {
		xmlFreeURI(source_uri_old);
	}
	g_strfreev(user_parts);
	return source;
}

/**
 * Compose changed feed source string from current dialog and subscription
 */
static gchar*
_batch_decode_source(BatchFeedProperty *self, subscriptionPtr subscription)
{
	gchar *source = NULL;
	GtkEntry *source_entry = GTK_ENTRY(_batch_get_object(self, "sourceEntry"));
	const gchar *entry_text = gtk_entry_get_text(source_entry);
	gboolean auth_changed = _batch_changed(self, "HTTPauth");

	if (auth_changed)
		source = _batch_decode_url_source(self, subscription);
	else if (_batch_checkbox_actived(self, "feed_loc_file"))
		source = g_strdup(entry_text);
	else if (_batch_checkbox_actived(self, "feed_loc_command"))
		source = g_strdup_printf ("|%s", entry_text);
	else
		source = _batch_decode_url_source(self, subscription);
	return source;
}

/**
 * Change one feed according to the batch change dialog settings
 */
static void
batch_feed_property_change_feed(BatchFeedProperty *self, subscriptionPtr subscription)
{
	gchar		*newSource = NULL;
	const gchar	*newFilter;
	GtkEntry	*entry;
	gboolean	needsUpdate = FALSE;
	nodePtr		node = subscription->node;
	feedPtr		feed = (feedPtr)node->data;

	if ( SUBSCRIPTION_TYPE(subscription) == feed_get_subscription_type ()) {
		/* source */
		if (_batch_changed(self, "feed_loc_") || _batch_changed(self, "HTTPauth")) {
			newSource = _batch_decode_source(self, subscription);

			if(newSource && g_strcmp0(newSource, subscription_get_source(subscription))) {
				subscription_set_source(subscription, newSource);
				needsUpdate = TRUE;
			}
			_g_free0_(newSource);
		} /* source */


		/* filter */
		if (_batch_changed(self, "filter")) {
			entry = GTK_ENTRY(_batch_get_object(self, "filterEntry"));
			newFilter = gtk_entry_get_text(entry);
			if (_batch_checkbox_actived(self, "filterCheckbox") && g_strcmp0(newFilter, "")) {
				if(g_strcmp0(newFilter, subscription_get_filter(subscription))) {
					subscription_set_filter(subscription, newFilter);
					needsUpdate = TRUE;
				}
			} else {
				if(subscription_get_filter(subscription)) {
					subscription_set_filter(subscription, NULL);
					needsUpdate = TRUE;
				}
			}
		} /* filter */

		/* updateInterval */
		if (_batch_changed(self, "updateInterval")) {
			if (_batch_checkbox_actived(self, "updateIntervalNever"))
				subscription_set_update_interval (subscription, -2);
			else if (_batch_checkbox_actived(self, "updateIntervalDefault"))
				subscription_set_update_interval (subscription, -1);
			else if (_batch_checkbox_actived(self, "updateIntervalSpecific")) {
				gint intervalUnit = gtk_combo_box_get_active (
						GTK_COMBO_BOX (_batch_get_object(self, "refreshIntervalUnitComboBox")));
				gint updateInterval = gtk_spin_button_get_value_as_int (
						GTK_SPIN_BUTTON (_batch_get_object(self, "refreshIntervalSpinButton")));
				if (intervalUnit == 1)
					updateInterval *= 60;	/* hours */
				else if (intervalUnit == 2)
					updateInterval *= 1440;	/* days */
				subscription_set_update_interval (subscription, updateInterval);
			}
		} /* updateInterval */

		/* "Download" Options */
		if (_batch_changed(self, "dontUseProxyCheck")) {
			subscription->updateOptions->dontUseProxy = _batch_checkbox_actived(self, "dontUseProxyCheck");
			needsUpdate = TRUE;
		}
	}

	/* "Archive" handling */
	if (_batch_changed(self, "feedCache")) {
		if(_batch_checkbox_actived(self, "feedCacheDefault"))
			feed->cacheLimit = CACHE_DEFAULT;
		else if(_batch_checkbox_actived(self, "feedCacheDisable"))
			feed->cacheLimit = CACHE_DISABLE;
		else if(_batch_checkbox_actived(self, "feedCacheUnlimited"))
			feed->cacheLimit = CACHE_UNLIMITED;
		else if(_batch_checkbox_actived(self, "feedCacheLimited"))
			feed->cacheLimit = gtk_spin_button_get_value(GTK_SPIN_BUTTON(_batch_get_object(self, "cacheItemLimit")));
	} /* "Archive" handling */


	/* "Advanced" options */
	if (_batch_changed(self, "enclosureDownloadCheck"))
		feed->encAutoDownload = _batch_checkbox_actived(self, "enclosureDownloadCheck");
	if (_batch_changed(self, "loadItemLinkCheck"))
		node->loadItemLink = _batch_checkbox_actived(self, "loadItemLinkCheck");
	if (_batch_changed(self, "ignoreCommentFeeds"))
		feed->ignoreComments = _batch_checkbox_actived(self, "ignoreCommentFeeds");
	if (_batch_changed(self, "markAsReadCheck"))
		feed->markAsRead = _batch_checkbox_actived(self, "markAsReadCheck");

	feed_list_node_update (node->id);
	feedlist_schedule_save ();
	db_subscription_update (subscription);
	if (needsUpdate)
		subscription_update (subscription, FEED_REQ_PRIORITY_HIGH);
}

/**
 * main dialog response handler function
 */
static void
on_batch_feed_property_dialog_response (GtkDialog* dlg, gint response_id, gpointer user_data)
{
	BatchFeedProperty * self = user_data;
	if (response_id == GTK_RESPONSE_OK) {
		GtkTreeView*tree;
		GtkTreeModel *model;
		GtkTreeSelection *selection;
		GList *rows = NULL;
		GList *row;
		tree = GTK_TREE_VIEW(_batch_get_object(self, "treeview_feed_list"));
		selection = gtk_tree_view_get_selection(tree);
		rows = gtk_tree_selection_get_selected_rows(selection, &model);
		if (!rows) return;
		for (row = rows; row != NULL; row = row->next) {
			GtkTreePath *path;
			GtkTreeIter miter;
			nodePtr node;
			path = row->data;
			if(!gtk_tree_model_get_iter(model, &miter, path))
				break;
			gtk_tree_model_get (model, &miter, FS_PTR, &node, -1);
			if (node->subscription) {
				batch_feed_property_change_feed(self, node->subscription);
			}
		}
		g_list_free_full (rows, (GDestroyNotify) gtk_tree_path_free);
	}

	gtk_widget_destroy(GTK_WIDGET(self->priv->main_dialog));
	self->priv->main_dialog = NULL; // otherwise `finalizer` will bark!
	_g_object_unref0(self);
	return;
}

/*
 * Keep track on which properties were changed
 */
void
on_batch_feed_property_changed (GtkWidget* wid, gpointer user_data)
{
	BatchFeedProperty * self = user_data;
	GtkWidget *box = NULL;
	const gchar* wname0 = gtk_buildable_get_name ((GtkBuildable*) wid);
	const gchar *wname;
	gint i;

	wname = wname0;
	for (i = 0; BOX_MAP[i].widget_prefix != NULL; i++) {
		if(g_str_has_prefix(wname, BOX_MAP[i].widget_prefix)) {
			wname = BOX_MAP[i].widget_prefix;
			box = (GtkWidget*)_batch_get_object (self, BOX_MAP[i].container_name);
			break;
		}
	}

	if (!g_hash_table_contains(self->priv->changed, wname)) {
		GtkStyleContext *style_context;
		g_hash_table_add(self->priv->changed, g_strdup(wname));
		if (NULL == box) {
			box = wid;
		}
		style_context = gtk_widget_get_style_context(GTK_WIDGET(box));
		gtk_style_context_add_class(style_context, BATCH_FEED_PROPERTY_CSS_CHANGED_CLASS);
	}

	wname = wname0;
	for (i = 0; SENSITIVE_MAP[i].widget_name != NULL; i++) {
		if(!g_strcmp0(wname, SENSITIVE_MAP[i].widget_name)) {
			GtkWidget *target;
			gboolean val;
			target = (GtkWidget*)_batch_get_object (self, SENSITIVE_MAP[i].target_name);
			val = _batch_checkbox_actived(self, wname);
			g_object_set (G_OBJECT (target), "sensitive", val, NULL);
			break;
		}
	}
}

/**
 * generic handler for GtkFileChooserDialog response handler with batchfeedproperty specific data
 */
static void
_batch_select_file_response(GtkFileChooserDialog *dlg, gint resp, gpointer user_data)
{
	struct BatchSelectFileData *sf_data = user_data;
	BatchFeedProperty * self = sf_data->self;
	if (resp == GTK_RESPONSE_ACCEPT)
	{
		GtkEntry *entry;
		gchar *filename;
		entry = GTK_ENTRY(_batch_get_object(self, sf_data->entry_name));
		filename = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dlg));
		g_object_set(G_OBJECT(entry), "text", filename, NULL);
		g_free(filename);
	}
	g_free(sf_data);
	gtk_widget_destroy(GTK_WIDGET(dlg));
}

static void
on_batch_feed_property_select_file(GtkWidget *wid, struct BatchSelectFileData *user_data)
{
	GtkFileChooserDialog *fdialog;
	BatchFeedProperty *self = user_data->self;
	gint res;
	fdialog = GTK_FILE_CHOOSER_DIALOG(
			gtk_file_chooser_dialog_new(
				user_data->title,
				GTK_WINDOW(self->priv->main_dialog),
				GTK_FILE_CHOOSER_ACTION_OPEN,
				_("_Cancel"), GTK_RESPONSE_CANCEL,
				_("_Select"), GTK_RESPONSE_ACCEPT,
				NULL));

	res = gtk_dialog_run (GTK_DIALOG (fdialog));
	_batch_select_file_response(fdialog, res, user_data);
}

void
on_batch_feed_property_select_source_file(GtkWidget *wid, gpointer user_data)
{

	struct BatchSelectFileData *select_data;
	select_data = g_new0(struct BatchSelectFileData, 1);
	select_data->title = _("Select Source File");
	select_data->entry_name = "sourceEntry";
	select_data->self = user_data;

	on_batch_feed_property_select_file(wid, select_data);
}

void
on_batch_feed_property_select_filter_file(GtkWidget *wid, gpointer user_data)
{

	struct BatchSelectFileData *select_data;
	select_data = g_new0(struct BatchSelectFileData, 1);
	select_data->title = _("Select Filter File");
	select_data->entry_name = "filterEntry";
	select_data->self = user_data;

	on_batch_feed_property_select_file(wid, select_data);
}

static void batch_feed_property_class_init (BatchFeedPropertyClass * klass) {
	batch_feed_property_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (BatchFeedPropertyPrivate));
	G_OBJECT_CLASS (klass)->finalize = batch_feed_property_finalize;
}

static void batch_feed_property_instance_init (BatchFeedProperty * self) {
	self->priv = BATCH_FEED_PROPERTY_GET_PRIVATE (self);
}


static void batch_feed_property_finalize (GObject* obj) {
	BatchFeedProperty * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_BATCH_FEED_PROPERTY, BatchFeedProperty);
	_g_hash_table_unref0 (self->priv->changed);
	_g_object_unref0 (self->priv->main_dialog);
	_g_object_unref0 (self->priv->builder);
	G_OBJECT_CLASS (batch_feed_property_parent_class)->finalize (obj);
}


GType batch_feed_property_get_type (void) {
	static volatile gsize batch_feed_property_type_id__volatile = 0;
	if (g_once_init_enter (&batch_feed_property_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = {
			sizeof (BatchFeedPropertyClass),
			(GBaseInitFunc) NULL,
			(GBaseFinalizeFunc) NULL,
			(GClassInitFunc) batch_feed_property_class_init,
			(GClassFinalizeFunc) NULL,
			NULL,
			sizeof (BatchFeedProperty),
			0,
			(GInstanceInitFunc) batch_feed_property_instance_init,
			NULL
		};
		GType batch_feed_property_type_id;
		batch_feed_property_type_id = g_type_register_static (G_TYPE_OBJECT, "BatchFeedProperty", &g_define_type_info, 0);
		g_once_init_leave (&batch_feed_property_type_id__volatile, batch_feed_property_type_id);
	}
	return batch_feed_property_type_id__volatile;
}

